/**
 * Лабораторная работа №2. Массивы объектов, простое наследование, виртуальные
 * функции, применение наследования.
 *
 * В этой работе и далее предполагается, что вы будете использовать классы,
 * написанные в прошлых работах, и дополнять их по необходимости. Эти классы
 * будут называться по имени без дополнительных указаний, что их надо взять из
 * прошлой работы.
 *
 * Предполагается, что новый классы будут созданы по аналогии с предыдущими
 * работами в отдельных файлах, которые будут включены в сборку.
 *
 * При работе с классами - в учебных целях - нельзя пользоваться контейнерами
 * стандартной библиотеки и нужно следовать принципам инкапсуляции.
 */

#include <iostream>
#include "../../lab1/src/myString.h"  
#include "BaseFile.h"
#include "other.h"
#include <cstring>

using namespace std;

int main() {
    /**
     * Задание 1. Массивы объектов класса.
     */

    /**
     * Задание 1.1. Массив объектов.
     *
     * Объявите и проинициализируйте массив ar из объектов типа MyString.
     * Выведите элементы массива на консоль.
     */

    {
        cout << "\n-----------\n\n---| Task 1.1 |---\n";
        MyString ar[5] = {"qqqewss", "eeweq", "dashjd", "EWQEQWE", "42332QW"};

        for (const auto& str : ar) {
            str.print();
        }
    }

    /**
     * Замените размер массива с 3 на 5, не меняя список инициализаторов.
     *
     * Чем были инициализированы последние 2 элемента? Какие значения могут
     * стоять в списке инициализаторов - в вашем случае и в общем случае?
     */

    // TODO: сделать это задание. СДЕЛАЛ работает!

    /**
     * Задание 1.2. Массив указателей на объекты.
     *
     * Объявите и проинициализируйте массив arPtr из трех указателей на объекты
     * типа MyString. Выведите элементы массива на консоль.
     */

    {
        cout << "\n---| Task 1.2 |---\n";
        MyString* arPtr[3] = {
        new MyString("ewrgh"),
        new MyString("sdpauihf"),
        new MyString("sdhjf jdsjsd")
        };

        for (const auto& str : arPtr) {
            str->print();
            delete str;
        }
    }

    /**
     * Задание 2. Простое наследование. Аргументы конструктора, передаваемые в
     * базовый класс.
     */

    /**
     * Задание 2.1. Базовый класс.
     *
     * Создайте класс BaseFile, который будет реализовывать работу с файлами с
     * помощью стандартных средств C (cstdio).
     *
     * Класс должен иметь 3 конструктора: первый - конструктор по умолчанию,
     * второй должен принимать путь к файлу и параметры для открытия (как в
     * fopen), третий должен принимать готовый указатель FILE*.
     *
     * Считается, что этот класс *обладает* своим ресурсом - открытым файлом.
     * Что должно быть в дестукторе этого класса?
     *
     * Добавьте следующие методы:
     * - bool is_open() - возвращает true, если файл успешно открыт;
     * - bool can_read() - возвращает true, если из файла можно считать данные;
     * - bool can_write() - возвращает true, если в файл можно записать данные;
     * - size_t write_raw(const void *buf, size_t n_bytes) - записывает
     *   указанное количество байт в файл и возвращает количество байт, которое
     *   удалось записать;
     * - size_t read_raw(void *buf, size_t max_bytes) - читает доступные данные
     *   в буфер, но не более указанного количества и возвращает количество
     *   байт, которое удалось считать;
     * - long tell() - возвращает текущий сдвиг файла (см. функцию ftell);
     * - bool seek(long offset) - устанавливает сдвиг файла (см. функцию fseek)
     *   и возвращает true, если операция успешна.
     *
     * Добавьте также методы `read` и `write`, которые в этом классе будут
     * делать буквально то же, что `read_raw` и `write_raw`, они понадобятся нам
     * позже.
     *
     * Проверьте работу этого класса.
     */
{
    cout << "\n---| Task 2.1(BaseFile) |---\n";

    cout << "-------- open(w) --------\n";
    BaseFile file("text.txt", "w");
    if (!file.is_open()) {  
        std::cerr << "errrorr\n";  
        return 1;  
    }  
    cout << "is_open - " << file.is_open() << "\n";
    cout << "can_read - " << file.can_read() << "\n";
    cout << "can_write - " << file.can_write() << "\n";

    const char data[] = "фауст";
    char buffer[100] = {0};
    // записываем
    size_t written = file.write_raw(data, sizeof(data));
    cout << "write_raw - " << written << "\n";

    // переоткрываем файл для чтения
    cout << "------- reopen(r) -------\n";
    file.reopen("text.txt", "r");
    cout << "can_read - " << file.can_read() << "\n";
    cout << "can_write - " << file.can_write() << "\n";

    // читаем из файла
    size_t read = file.read_raw(buffer, written);
    cout << "read_raw - " << read << "\n";
    cout << "data: " << buffer << "\n";

    cout << "\ntell - " << file.tell() << "\n";
    cout << "seek - " << file.seek(3) << "\n";
    cout << "tell - " << file.tell() << "\n";
}

    /**
     * Задание 2.2. Производные классы.
     *
     * Производный класс *наследуется* от базового класса и каким-то образом
     * расширяет его функциональность, при это все еще умея все, что умеет
     * базовый класс.
     *
     * Реализуйте следующие производные классы от класса BaseFile. Производные
     * классы нужно унаследовать так, чтобы пользователю были все еще доступны
     * методы базового класса. Каким образом нужно унаследовать класс для этого?
     * Как еще можно унаследовать класс?
     *
     * Производные классы могут располагаться в том же файле, где и базовый
     * класс.
     *
     * В производных классах добавьте необходымые конструкторы, которые будут
     * вызывать конструктор базового класса.
     *
     * Проверьте работу производных классов.
     */
    {
        cout << "\n---| Task 2.2(BaseFile32) |---\n";
        const char data[] = "мефистофель";
        char buffer[100] = {0};

        cout << "-------- open(r) --------\n";
        BaseFile32 file("text.txt", "r");
        cout << "is_open - " << file.is_open() << "\n";
        cout << "can_read - " << file.can_read() << "\n";
        cout << "can_write - " << file.can_write() << "\n";

        // читаем предыдущюю запись(фауст)декод32
        size_t file_size = file.get_file_size();
        size_t read = file.read(buffer, file_size);
        cout << "read - " << read << "\n";
        cout << "data: (пусто думаю из-за 64 и 32)" << buffer << "\n";

        cout << "------- reopen(w) -------\n";
        file.reopen("text.txt", "w");
        cout << "can_read - " << file.can_read() << "\n";
        cout << "can_write - " << file.can_write() << "\n";

        // запись код32
        size_t written = file.write(data, sizeof(data));
        cout << "write - " << written << "\n";

        cout << "------- reopen(r) -------\n";
        file.reopen("text.txt", "r");
        cout << "can_read - " << file.can_read() << "\n";
        cout << "can_write - " << file.can_write() << "\n";

        // читаем декод32
        read = file.read(buffer, written);
        cout << "read - " << read << "\n";
        cout << "data: " << buffer << "\n";


        // пароверяем ftell и fseek
        cout << "\ntell - " << file.tell() << "\n";
        cout << "seek - " << file.seek(5) << "\n";
        cout << "tell - " << file.tell() << "\n";
    }
    /**
     * Задание 2.2.1. Base32 кодировщик/декодировщик.
     *
     * Создайте производный класс Base32File, который будет проводить при
     * записи кодировку-декодировку данных, по алгоритму, который вы
     * реализовали в лабораторной работе №4 прошлого семестра.
     *
     * Переопределите методы `read` и `write`, которые будут проводить чтение из
     * файла с декодировкой и запись в файл с кодировкой соответственно.
     *
     * Добавьте возможность пользователю передать в конструктор таблицу
     * кодировки, по умолчанию используется таблица "A..Z1..6".
     */

    /**
     * Задание 2.2.2. RLE-сжатие.
     *
     * Создайте производный класс RleFile, который будет проводить побайтовое
     * сжатие при помощи алгоримта RLE (для простоты можно реализовать
     * неэффективный алгоритм, где последовательности без повторений отдельно
     * не кодируются).
     *
     * Переопределите методы `read` и `write`, которые будут проводить чтение из
     * файла с извлечением сжатой информации и запись в файл со сжатием
     * соответственно.
     *
     * Проверьте сжатие/извлечение на примере какого-нибудь ASCII-арта,
     * например, котенка из лабораторной №3 прошлого семестра. Посмотрите,
     * получилось ли добиться уменьшения размера хранимых данных.
     */
    {
        cout << "\n---| Task 2.2.2(RLE) |---\n";
        const char* case1 = "AAAAAABBBBBCCCCDDDFFG";
        const char* case2 = "ABABABCDCDCDFGFGFGFGF";
        char buffer[100] = {0};

        cout << "-------- open(w) --------\n";
        RleFile file("text.txt", "w");
        cout << "is_open - " << file.is_open() << "\n";
        cout << "can_read - " << file.can_read() << "\n";
        cout << "can_write - " << file.can_write() << "\n";

        // записываем сase1
        cout << "---- case1: ----\n";
        size_t written1 = file.write(case1, strlen(case1)); 
        cout << "write(case1) - " << written1 << "\n";
        //[6 'A'] [5 'B'] [4 'C'] [3 'D'] [2 'F'] [1 'G'] - 12байтов


        file.reopen("text.txt", "r");

        // я меняю бы written1 на сайзоф то уже все гуд
        // считываем case1
        size_t read1 = file.read(buffer, sizeof(buffer) - 1);
        cout << "read(case1) - " << read1 << "\n";
        cout << "data: " << buffer << "\n";
        // восстанавливает исходн поэтому 21

        file.reopen("text.txt", "w");

        // записываем сase2
        cout << "---- case2: ----\n";
        size_t written2 = file.write(case2, strlen(case2));
        cout << "write(case2) - " << written2 << "\n";
        //[1 'A'] [1 'B'] [1 'A'] [1 'B'] [1 'A'] [1 'B'] ... - 42байта

        file.reopen("text.txt", "r");

        // считываем case2
        size_t read2 = file.read(buffer, sizeof(buffer) - 1);
        cout << "read(case2) - " << read2 << "\n";
        cout << "data: " << buffer << "\n";
        // восстанавливает исходн поэтому 21

    }    
    /** 
     * Задание 2.3. Конструкторы и деструкторы базового и производного классов.
     *
     * Установите отладочную печать в конструкторах и деструкторах каждого
     * класса из этого задания. Создайте локальные объекты производных классов,
     * отметьте, в каком порядке вызываются конструкторы и деструкторы при
     * инициализации и деинициализации этих классов.
     */
    {
        // cout << "---| Test 2.3: Конструкторы и деструкторы |---\n";

        // cout << "\n...BaseFile...\n";
        // BaseFile base("test.txt", "w");

        // cout << "\n...BaseFile32...\n";
        // BaseFile32 base32("test.txt", "w");

        // cout << "\n...RleFile...\n";
        // RleFile rle("test.txt", "w");

        // cout << "\n...destructors... \n";
    }

    /**
     * Задание 2.4. Ранее связывание.
     *
     * На основе данной заготовки напишите код, который запишет в файл строковое
     * представление целого числа. Вы должны использовать один и тот же код для
     * всех файлов, меняя только имя объекта (bf / b32f / rf), в который идетf
     * запись.
     */

    // TODO: чем отличается виртуальные функции от не виртуальных?
    // чем переопределение виртуальной функции в наследнике отличается 
    // от переопределения не виртульной функции в наследнике?
    // как происходит вызов виртуальной функции?
    {
        cout << "\n---| Task 2.4 |---\n";
        int n = 123456;
        char buffer[100] = {0};

        BaseFile bf("base.txt", "w");
        write_number(&bf, n);
        bf.reopen("base.txt", "r");
        size_t readbf = bf.read(buffer, bf.get_file_size());
        cout << "buffer bf: " << buffer << "\n";

        BaseFile32 b32f("base32.txt", "w");
        write_number(&b32f, n);
        b32f.reopen("base32.txt", "r");
        size_t readb32f = b32f.read(buffer, b32f.get_file_size());
        cout << "buffer b32f: " << buffer << "\n";

        RleFile rf("rle.txt", "w");
        write_number(&rf, n);
        rf.reopen("rle.txt", "r");
        size_t readrf = rf.read(buffer, rf.get_file_size());
        cout << "buffer rf: " << buffer << "\n";
    }

    /**
     * Задание 2.5. Передача объекта по ссылке / указателю.
     *
     * Прошлое задание выглядит странновато - зачем повторять код три раза?
     * Хорошо бы сделать функцию, которая примет объект файла и число, и
     * выполнит эти действия.
     *
     * Реализуйте функцию `write_int(BaseFile &file, int n)`, которая будет
     * принимать ссылку на файл и число, которое нужно будет напечатать.
     *
     * Приницип наследования предписывает, что везде, где можно использовать
     * базовый класс, можно использовать производный класс. Проверьте, можно
     * ли вызвать функцию, передав в нее объект класса Base32File и RleFile.
     *
     * Имеет ли вызов этой функции для производного класса тот же результат,
     * что и код, который вы написали выше? Почему?
     */
    {
        BaseFile file("test.txt", "w");
        write_int(file, 12345);

        BaseFile32 base32File("test_base32.txt", "w");
        write_int(base32File, 67890);

        RleFile rleFile("test_rle.txt", "w");
        write_int(rleFile, 54321);
    }

    /**
     * Задание 2.6. Виртуальные функции, позднее связывание.
     *
     * Объявите функции read и write в базовом классе *виртуальными*. Что это
     * означает? Как изменился размер объектов классов BaseFile, Base32File и
     * RleFile? Почему?
     * virtual может быть переопределён в производных классах
     * BaseFile 16 байт (указатели file, mode)  24 байта (+8 байт на vtable)
     * Base32File  24 байта (BaseFile + encodingTable) 32 байта (+8 байт на vtable)
     * RleFile 16 байт (наследует BaseFile)    24 байта (+8 байт на vtable)  
     *
     * Как изменилось поведение при вызове функции `write_int` для производных
     * классов? Почему?
     * до вызывается BaseFile::write даже если не бейсфайл
     * после вызывается только тот что вызовут
     * 
     */

    /**
     * Задание 2.7. Виртуальный деструктор.
     *
     * В следующем блоке кода добавьте удаление динамической памяти.
     *
     * Какой деструктор при этом вызывается? Почему? К каким проблемам это может
     * привести?
     * версия выбирается не компилятором, а уже во время исполнения
     * при удалении памяти вызывается лишь деструктор бейзфайл
     * из-за этого будут утечки
     *
     * Исправьте эту ситуацию.
     * дискрутор виртуальные -> может вызываться и ~RleFile...
     */

    {
        BaseFile* files[] = { 
            new BaseFile("base.txt", "w"), 
            new RleFile("rle.txt", "w"), 
            new BaseFile32("base32.txt", "w")
        };

        for (int i = 0; i < 3; ++i) {
            files[i]->write("hello!", 6);
        }

        for (int i = 0; i < 3; ++i) {
            delete files[i]; 
        }
    }

    /**
     * Задание 2.8. Массив объектов производных классов.
     *
     * Раскомментируйте следующий блок и объясните, почему:
     * а) не возникает ошибок при компиляции;
     * потому что все приводится к базовому типу все наследуется и все гуд
     * б) возникают ошибки при выполнении.
     * разное количество памяти выделилось на этапе компиляции
     * и во время выполнения из-за vtab
     *
     * Этот пример показывает очень плохую практику, которая приводит к ошибкам;
     * для создания массива объектов производного класса и используйте массив
     * указателей на базовый класс, как это было сделано выше. Реализуйте ту же
     * логику, используя массив указателей на объекты базового класса.
     */

    // {
    //     BaseFile *base_files = new BaseFile[2] { BaseFile(...), BaseFile(...) };
    //     BaseFile *b32_files = new Base32File[2] { BaseFile32(...), BaseFile32(...) };
    //     for (int i = 0; i < 2; ++i) {
    //         base_files[i].write("Hello!", 6);
    //         b32_files[i].write("Hello!", 6);
    //     }
    //     delete [] base_files;
    //     delete [] b32_files;
    // }
    {
        BaseFile* files[] = { new BaseFile("test.txt", "w"), new BaseFile32("test_base32.txt", "w") };

        for (int i = 0; i < 2; ++i) {
            files[i]->write("Hello!", 6);
        }

        for (int i = 0; i < 2; ++i) {
            delete files[i];
        }
    }
    /**
     * Задание 3. Чисто виртуальные функции. Интерфейсы. Композиция классов.
     *
     * Наследование позволяет довольно просто переиспользовать данные и логику
     * других классов, однако зачастую этот механизм недостаточно гибкий для
     * полноценного переиспользования.
     *
     * Например, сможем ли мы в получившейся иерархии классов реализовать
     * одновременно и кодирование в base32, и сжатие при записи данных в файл?
     * нет, ибо мы используем насоедование
     * нам нужно либо создать новый смежный класс внутри которого будут преобразования
     * и он тоже будет наследован от базового
     * либо переписать все с помощью композиций
     * Или сможем ли мы вместо записи в файл на диске делать запись в строковый
     * буфер в памяти? 
     * в память напрямую нет, ибо все классы работают с файлом
     * мы можем написать другие структуры которые будут взаимодействовать с нашими и тд

     *
     * При дальнейшем рассмотрении окажется, что при помощи наследования мы
     * крепко *связали* логику преобразования данных с записью в конкретный
     * файл. Далее мы рассмотрим один из способов разделения такой логики.
     */

    /**
     * Задание 3.1. Абстрактный базовый класс, чисто виртуальные функции.
     *
     * Первая проблема в нашей реализации - все наследники BaseFile будут всегда
     * обязаны непосредственно писать в файл на диске. Чтобы избавиться от этой
     * необходимости, стоит сделать базовый класс *абстрактным* в том смысле,
     * что у него не будет полей связанных с контретным способом писать в файл.
     * 
     * Создайте класс `IFile`, в котором не будет полей, но будут методы
     * `can_read`, `can_write`, `read` и `write` с такими же сигнатурами, как и
     * классе `BaseFile`. Что именно будут делать эти методы? Класс `IFile` не
     * может знать, поскольку логику этих методов будут определять наследники.
     * В этом классе эти методы не имеют реализации, и они должны быть объявлены
     * *чисто виртуальными*.
     *
     * Какие ограничения накладывает на класс наличие чисто виртуального метода?
     * нельзя создать объект этого класса
     * наследники должны реализовать чисто виртуальные методы
     * чисто виртуальные методы обеспечивают общий интерфейс для всех наследников
     * 
     * Получается, что в классе `IFile` есть только чисто виртуальные методы, и
     * единственная цель такого класса - определять, что должны уметь делать его
     * наследники. Совокупность действий, которые можно сделать с объектом,
     * называется его *интерфейсом*, и такие классы тоже часто называются
     * интерфейсами, отсюда берется приставка "I" в имени класса.
     *
     * Унаследуйте класс `BaseFile` от класса `IFile` и измените функцию
     * `write_int`, чтобы она работала с произвольным наследником `IFile`.
     *
     * Убедитесь, что в программе выше ничего не сломалось.
     */

    /**
     * Задание 3.2. Композиция вместо наследования.
     *
     * Реализуйте классы `Base32File2` и `RleFile2`, которые будут унаследованы
     * от класса `IFile` и в конструкторе будут получать другой объект `IFile`,
     * чьи функции они будут использовать вместо функций базового класса.
     *
     * Объекты получают объект `IFile` в виде указателя на динамически
     * выделенную память, и они ответственны за ее очищение.
     *
     * Использование объектом другого объекта в качестве поля называется
     * *композицией*.
     *
     * Проверьте, что используемые ниже объекты работают так же, как объекты
     * классов `Base32File` и `RleFile`.
     */

    {
        Base2File32 b32f(new BaseFile("test.txt", "w"));
        RleFile2 rf(new BaseFile("text.txt", "w"));
        write_int(b32f, 123456);
        write_int(rf, 123456);
    }

    /**
     * Задание 3.3. Больше композиции!
     *
     * Не реализовывая больше никаких классов, соорудите объект-наследник IFile,
     * который будет при вызове метода `write` два раза кодировать в base32,
     * после чего применять сжатие RLE и только после этого писать в файл.
     */

    {
        // композиция, цепочка оберток вокруг базового класса
        // каждый слой выполняет доп обработку данных перед записью
        // TODO: проверить, что это работает, и что данные можно считать так же
        IFile* file = new Base2File32(
            new Base2File32(
                new RleFile2(
                    new BaseFile("test.txt", "w")
                )
            )
        );

        write_int(*file, 123456); // base32 -> base32 -> rle -> write

        IFile* file1 = new Base2File32(
            new Base2File32(
                new RleFile2(
                    new BaseFile("test.txt", "r")
                )
            )
        );

        char buffer[256];  
        size_t read_size = file1->read(buffer, sizeof(buffer));
        cout << "decoded data: " << buffer << endl;
        // cout << read_size << endl;
        //считываем из бейз распоковка в RLE декод из Base32 декод из Base32
        delete file1; // т.к указатели на классы
        delete file;
    }

    return 0;
}   
